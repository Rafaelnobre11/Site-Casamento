// This is an autogenerated file from Firebase Studio.
import {
  doc,
  setDoc,
  addDoc,
  deleteDoc,
  updateDoc,
  collection,
  type Firestore,
  type WithFieldValue,
  type CollectionReference,
  type DocumentReference,
} from 'firebase/firestore';

import { errorEmitter } from '../error-emitter';
import { FirestorePermissionError, type SecurityRuleContext } from '../errors';


export async function setDocument<T>(
  db: Firestore,
  path: string,
  data: WithFieldValue<T>,
  options?: { merge: boolean }
) {
  const ref = doc(db, path) as DocumentReference<T>;

  return setDoc(ref, data, options).catch((error) => {
    const permissionError = new FirestorePermissionError({
      path: ref.path,
      operation: 'update',
      requestResourceData: data,
    });
    errorEmitter.emit('permission-error', permissionError);
    // re-throw the error so the caller can handle it
    throw error;
  });
}

export async function addDocument<T>(
  db: Firestore,
  path: string,
  data: WithFieldValue<T>
) {
  const ref = collection(db, path) as CollectionReference<T>;

  return addDoc(ref, data).catch((error) => {
    // Only handle permission errors with the custom emitter.
    // For other errors (like network issues, validation), let them propagate.
    if (error.code === 'permission-denied') {
        const permissionError = new FirestorePermissionError({
          path: ref.path,
          operation: 'create',
          requestResourceData: data,
        });
        errorEmitter.emit('permission-error', permissionError);
    }
     // re-throw the error so the caller can handle it and show a toast
    throw error;
  });
}

export async function updateDocument<T>(
  db: Firestore,
  path: string,
  data: Partial<WithFieldValue<T>>
) {
  const ref = doc(db, path) as DocumentReference<T>;

  return updateDoc(ref, data).catch((error) => {
    const permissionError = new FirestorePermissionError({
      path: ref.path,
      operation: 'update',
      requestResourceData: data,
    });
    errorEmitter.emit('permission-error', permissionError);
     // re-throw the error so the caller can handle it
    throw error;
  });
}

export async function deleteDocument(db: Firestore, path: string) {
  const ref = doc(db, path);

  return deleteDoc(ref).catch((error) => {
    const permissionError = new FirestorePermissionError({
      path: ref.path,
      operation: 'delete',
    });
    errorEmitter.emit('permission-error', permissionError);
     // re-throw the error so the caller can handle it
    throw error;
  });
}
